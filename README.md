# Проекты

## Infrastructure
Основная часть - добавка к Ninject, чтобы он мог брать несколько частичных функций и объединять их. Это вместо паттерна Visitor, так можно добавлять обработку разных случаев по кусочкам.

* `TaggedFunction` — тип вместо `Func<>`, чтобы не объединять случайные `Func`. Первый generic-параметр — произвольный тип, чтобы можно было строить независимые иерархии `TaggedFunction`.
* `PartialFunctionCombiningMissingBindingResolver` — компонент для Ninject, который при запросе `TaggedFunction<PartialFunctionCombined<T1>, T2, T3>` берёт все `TaggedFunction<T1, T2, T3>` и конструирует из них одну большую функцию, которая пробует все реализации по очереди, пока не получит не-default (обычно не-null).

К сожалению, я не сразу обнаружил, что у Ninject есть ещё и хитрая схема составления планов инъекций, так что к ней я не подключился. Как следствие, полезла пара костылей (см. `TODO`).

## SyntaxTree
Определения промежуточного синтаксического дерева.
В некотором смысле это отдельный язык программирования, являющийся пересечением Java/C++/etc.

## JavaPlugin
Реализация `IProgramParser` для Java.
Испольузует [http://javaparser.org/](JavaParser) и [https://www.ikvm.net/](IKVM), чтобы запустить эту Java-библиотеку в .NET.

## CppPlugin
Реализация `IProgramPrinter` для C++.
Просто конкатенирует строчки.

## BinaryExpressionPlugin
Пример расширяемого поведения: добавление бинарных выражений.
Включает в себя новый элемент синтаксического дерева, а также его парсер для Java и принтер для C++.

# Ожидаемое поведение

Должны работать создание переменных типа `int`, `long`, `char`, `boolean` и их инициализация
бинарными выражениями с константами, другими переменными и операциями `+`, `-`, `*`, `/`, `==`.

Присваивания переменных нет, равно как и ввода-вывода.
